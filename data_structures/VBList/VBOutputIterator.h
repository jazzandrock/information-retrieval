//
//  VBOutputIterator.h
//  IR
//
//  Created by User on 2/19/18.
//  Copyright (c) 2018 Oleg. All rights reserved.
//

#ifndef IR_VBOutputIterator_h
#define IR_VBOutputIterator_h


// I want to allow only iterators of char
// to be allowed. (what I want even more is basic_ifstream<unsigned char>)
// one way: https://stackoverflow.com/questions/4354665/function-that-takes-an-stl-iterator-over-any-container-of-a-elements-of-a-specif


// bool terminating template argument:
// if true, we terminate the stream after each written number
// (and at the very beginning, in the constructor) and then
// overwrite the terminating character when writing a new number.
// can be set to false if OutputIterator_t doesn't support overwriting
// same elements.
// I put it in template parameters because then in the generated bytecode
// there is no checking, it's as if i used #ifdef or something.
// moreover, if you create a VBOutputIterator for some iterator,
// the iterator either supports overwriting or doesn't, so this boolean
// is a one-time decision, totally ok to hold it in template parameters.
// looks ugly though.
template <class OutputIterator_t, class num_t, bool terminating>
class VBOutputIterator
    {
    public:
    typedef num_t value_type;
    typedef num_t& reference;
    typedef num_t* pointer;
    typedef std::output_iterator_tag iterator_category;
    
    // note that I'm taking &out as a parameter, and _out is & as well
    // this is done so that I can take, for example, ostreambuf_iterator
    // which is noncopyable. But I don't really like the solution
    explicit
    VBOutputIterator(OutputIterator_t & out)
        : _out(out)
        {
        // so far there are no elements, so terminate the "stream"
        if (terminating) terminate();
        }
    
    VBOutputIterator& operator=(VBOutputIterator const & other)
        {
        _out = other._out;
        return *this;
        }
    
    VBOutputIterator&
    operator=(num_t n)
        {
        if (n == 0) throw std::invalid_argument("we don't store zeros here");
        
        // "you are not expected to understand this"
        char _arr_buf[sizeof(num_t)*8/7 + 1];
        char* i = _arr_buf;
        do  {
            *i = n & 0x7F;
            ++i;
            n >>= 7;
            } while (n > 0);
        // now i points to the one past end character of our sequence

        _arr_buf[0] |= 0x80;
        
        // write bytes in reverse order to the out stream
        while (i != _arr_buf)
            {
            --i;
            *_out = *i;
            ++_out;
            }
            
        if (terminating) terminate();
            
        return *this;
        }
        
    // my stream of bytes is terminated by 0x80 character,
    // it's like null-terminated string
    inline void terminate() { *_out = 0x80; }
        
    // these are no-op, as they are in ostreambuf_iterator
    // hey, and how can make them a no-op?
    // I don't know how long the next number would be,
    // so I can't reserve space for them, so I can't
    // increment iterator without writing a number.
    VBOutputIterator& operator*() { return *this; }
    VBOutputIterator& operator++() { return *this; }
    VBOutputIterator& operator++(int) { return *this; }
        
    private:
    // most such restrictions are due to
    // ostreambuf_iterator and alike iterators
    // that can't be copied. But maybe I should
    // that class so that it works with char arrays
    // (which can be copied, where you can overwrite
    // one location several times) and then if
    // my class client wants to pass ostreambuf_iterator
    // and decides to take a copy, it won't compile or
    // maybe some bug will be introduced, but that's
    // just his problem.
    //
    // so what should I do: restrict or let the user decide?
//    DISALLOW_COPY_AND_ASSIGN(VBOutputIterator);
    
    // this is where the output goes
    OutputIterator_t & _out;
    };

#endif
